# 简单核
import torch
from torch import nn
from d2l import torch as d2l


# 二维互相关运算
# 理解为从原始矩阵中取出和卷积核大小相同的块与卷积核进行互相关运算
# X为原始矩阵，K为核
def corr2d(X, K):
    # 读取卷积核的大小
    h, w = K.shape
    # 初始化生成依次互相关运算后形成的新矩阵（这步只关注大小）
    # X->(i,j) K->(h,w) -->Y(i-h+1,j-w+1)
    Y = torch.zeros((X.shape[0] - h + 1, X.shape[1] - w + 1))
    # Y的行列数表示核在原始矩阵上向右/向下平移几次
    # 循环依次计算
    for i in range(Y.shape[0]):
        for j in range(Y.shape[1]):
            Y[i, j] = (X[i:i + h , j:j + w] * K).sum()
    return Y

'''
# 验证
X = torch.tensor([[0.0, 1.0, 2.0], 
                  [3.0, 4.0, 5.0], 
                  [6.0, 7.0, 8.0]])   # 3*3
K = torch.tensor([[0.0, 1.0], 
                  [2.0, 3.0]])  # 2*2
# 预计生成Y为2*2
print(corr2d(X, K))
# tensor([[19., 25.], 
#         [37., 43.]])  done!
'''

# 卷积层
class Conv2D(nn.Module):
    # 这里较MLP不同的是需要有kernel_size这个参数，即核大小
    def __init__(self, kernel_size):
        super().__init__()
        self.weight = nn.Parameter(torch.rand(kernel_size))
        self.bias = nn.Parameter(torch.zeros(1))
    
    def forward(self, X):
        # 这里的前向计算较MLP来说就是把简单矩阵乘法变成与卷积核的互相关运算
        return corr2d(X, self.weight) + self.bias

# 简单应用(检测边缘)
X = torch.ones((6, 8))
X[:, 2:6] = 0
'''
# print(X)
tensor([[1., 1., 0., 0., 0., 0., 1., 1.],
        [1., 1., 0., 0., 0., 0., 1., 1.],
        [1., 1., 0., 0., 0., 0., 1., 1.],
        [1., 1., 0., 0., 0., 0., 1., 1.],
        [1., 1., 0., 0., 0., 0., 1., 1.],
        [1., 1., 0., 0., 0., 0., 1., 1.]])
'''
K = torch.tensor([[1.0, -1.0]]) # sobel算子
Y = corr2d(X, K)
print(Y)
'''
黑到白为1，白到黑为-1？
tensor([[ 0.,  1.,  0.,  0.,  0., -1.,  0.],
        [ 0.,  1.,  0.,  0.,  0., -1.,  0.],
        [ 0.,  1.,  0.,  0.,  0., -1.,  0.],
        [ 0.,  1.,  0.,  0.,  0., -1.,  0.],
        [ 0.,  1.,  0.,  0.,  0., -1.,  0.],
        [ 0.,  1.,  0.,  0.,  0., -1.,  0.]])
'''
# 如果检测水平边缘？
print(corr2d(X.t(), K))
# 无法检测
# tensor([[0., 0., 0., 0., 0.],
#         [0., 0., 0., 0., 0.],
#         [0., 0., 0., 0., 0.],
#         [0., 0., 0., 0., 0.],
#         [0., 0., 0., 0., 0.],
#         [0., 0., 0., 0., 0.],
#         [0., 0., 0., 0., 0.],
#         [0., 0., 0., 0., 0.]])

# 学习由X生成Y的卷积核
# 给定原图像X，结果Y，希望学习出前面定义的torch.tensor([[1.0, -1.0]])
# 构造一个二维卷积层，它具有1个输出通道和形状为（1，2）的卷积核
conv2d = nn.Conv2d(1, 1, kernel_size=(1, 2), bias=False)
# 这个二维卷积层使用四维输入和输出格式（批量大小、通道、高度、宽度）
X = X.reshape(1, 1, 6, 8)
Y = Y.reshape(1, 1, 6, 7)

# 简单训练逻辑
for i in range(20):
    Y_hat = conv2d(X)
    # 平方误差
    loss = (Y_hat - Y) **2
    conv2d.zero_grad()
    loss.sum().backward()
    # 裸写乞丐版SGD
    # 手动设置学习率3e-2 2333333~
    conv2d.weight.data[:] -= 3e-2 * conv2d.weight.grad
    if (i + 1) % 2 == 0:
        print(f'batch {i+1}, loss {loss.sum():.3f}')

# 验证最后更新完的权重W是否与预期的K = torch.tensor([[1.0, -1.0]])相似
K_train = conv2d.weight.data.reshape((1, 2))
# 不reshape实际上生成tensor([[[[ 0.9800, -1.0033]]]])
print(K_train)  # tensor([[ 0.9422, -1.0314]])

# 练习 构建一个具有对角线边缘的图像 X
X = torch.ones((8, 8))
for i in range(X.shape[0]):
    for j in range(X.shape[1]):
        if i == j :
            X[i, j] = 0
'''
print(X)
tensor([[0., 1., 1., 1., 1., 1., 1., 1.],
        [1., 0., 1., 1., 1., 1., 1., 1.],
        [1., 1., 0., 1., 1., 1., 1., 1.],
        [1., 1., 1., 0., 1., 1., 1., 1.],
        [1., 1., 1., 1., 0., 1., 1., 1.],
        [1., 1., 1., 1., 1., 0., 1., 1.],
        [1., 1., 1., 1., 1., 1., 0., 1.],
        [1., 1., 1., 1., 1., 1., 1., 0.]])
'''            

# (1).将本节中举例的卷积核 K 应用于 X
Y = corr2d(X, K)
'''
print(Y)
tensor([[-1.,  0.,  0.,  0.,  0.,  0.,  0.],
        [ 1., -1.,  0.,  0.,  0.,  0.,  0.],
        [ 0.,  1., -1.,  0.,  0.,  0.,  0.],
        [ 0.,  0.,  1., -1.,  0.,  0.,  0.],
        [ 0.,  0.,  0.,  1., -1.,  0.,  0.],
        [ 0.,  0.,  0.,  0.,  1., -1.,  0.],
        [ 0.,  0.,  0.,  0.,  0.,  1., -1.],
        [ 0.,  0.,  0.,  0.,  0.,  0.,  1.]])
可以提出边缘
'''
# (2).如果转置 X 会发生什么？
Y = corr2d(X.t(), K)
# print(Y)
# 没啥区别，转置了还是对角线边缘

# (3).如果转置 K 会发生什么？
Y = corr2d(X, K.t())
# print(Y)
# 没啥区别，转置了还是可以提取出水平边缘，不转置可能是提取垂直边缘