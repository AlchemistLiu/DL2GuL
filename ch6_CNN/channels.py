# 多输入多输出通道
import torch
from d2l import torch as d2l

# 多通道的结果是所有通道卷积结果的和
# 能处理多个通道|输入|的互相关运算
# X-->3d    K-->3d  out-->2d
# 将每个通道相同像素的结果加到一起
def corr2d_multi_in(X, K):
    # zip()对输入通道的维度做遍历
    return sum(d2l.corr2d(x, k) for x, k in zip(X, K))

X = torch.tensor([[[0.0, 1.0, 2.0], [3.0, 4.0, 5.0], [6.0, 7.0, 8.0]],
               [[1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0]]])
# 2*3*3
K = torch.tensor([[[0.0, 1.0], [2.0, 3.0]], [[1.0, 2.0], [3.0, 4.0]]])
# 2*2*2
result = corr2d_multi_in(X, K)
print(result)
# 2*2
# tensor([[ 56.,  72.],
#         [104., 120.]])


# 能处理多个通道|输出|的互相关运算
'''
输入和卷积核相同都是3d的时候，进行互相关运算时输出是一个2d的张量
如果想要输出是一个3d的张量？
需要对卷积核进行修改，增加卷积核的维度到4d
抛开卷积核的第一维度，以X-->2*3*3 K-->3*2*2*2来理解
此时X-->2*3*3一个图片 K_hat-->2*2*2两通道的图片？
依照上面例子所表示，输出一个3*3的图片
现在情况可以理解为单独拿出来卷积核第一维的通道1来与X做卷积，
即X-->2*3*3   K_hat-->1*2*3*3
可以理解为卷积核中每个三维的核代表一种过滤器？最后生成的3*2*2
的结果可以理解为三个2*2的图片，每个图片中是不同的特征，分别在三个通道中
'''
# eg X-->3d    K-->4d   out-->3d
def corr2d_multi_in_out(X, K):
    # stack堆积维度？在第0维堆积
    # for k in K 拿出K中第一个通道的3d数据k?
    return torch.stack([corr2d_multi_in(X, k) for k in K], 0)

# 堆出一个用来测试的4d K-->3*2*2*2
K = torch.stack((K, K + 1, K + 2), 0)
# X-->2*3*3
result = corr2d_multi_in_out(X, K)
print(result)
print(result.shape)     # torch.Size([3, 2, 2])
'''
用  𝑐𝑖  和  𝑐𝑜  分别表示输入和输出通道的数目，并让  𝑘ℎ  和  𝑘𝑤  为卷积核的高度和宽度。
为了获得多个通道的输出，我们可以为每个输出通道创建一个形状为  𝑐𝑖×𝑘ℎ×𝑘𝑤  的卷积核张量，
这样卷积核的形状是  𝑐𝑜×𝑐𝑖×𝑘ℎ×𝑘𝑤 
eg:
用  2  和  3  分别表示输入和输出通道的数目，并让  𝑘ℎ  和  𝑘𝑤  为卷积核的高度和宽度。
为了获得多个通道的输出，我们可以为每个输出通道创建一个形状为  2×2×2  的卷积核张量，
这样卷积核的形状是  3×2×2×2 
'''

# 1*1卷积
# 等价于一个全连接层？
def corr2d_multi_in_out_1x1(X, K):
    # 输入通道数，高，宽
    c_i, h, w = X.shape
    # 输出通道数
    c_o = K.shape[0]
    # 不关心他的空间，只关心通道
    X = X.reshape((c_i, h * w))     # 3*9
    K = K.reshape((c_o, c_i))       # 2*3
    Y = torch.matmul(K, X)
    return Y.reshape((c_o, h, w))   # 2*3*3

X = torch.normal(0, 1, (3, 3, 3))   # 3*3*3
K = torch.normal(0, 1, (2, 3, 1, 1))    # 2*3*1*1
'''
K的最大维度为多少，最后输出的结果就为几通道？
照例拆开看X-->3*3*3 OUT-->2*3*3 K-->2*3*1*1
X变为3*9-->将维度压缩，把X每个通道上的数据压缩成一个行向量？
K为2*3*1*1 1可以将K的维度压缩为2*3即将每个像素的数据看成对标的通道？
OUT为2*9-->2*3*3 
理解为将X三个通道上的相同像素的值变化后相加，即只关注这个像素的通道信息？  
2*3的第一行为对该通道的一种变化
(因为计算的时候是K2*3的第一行乘以X3*9的第一列，这一列代表的就是这一个像素三个通道的值?)
因为是1X1所以可以说是不识别空间信息!
类比非1x1卷积核，这个关注的是图像的通道信息
done!
'''
# 需要日后继续理解
# ********************************************

Y1 = corr2d_multi_in_out_1x1(X, K)
Y2 = corr2d_multi_in_out(X, K)
assert float(torch.abs(Y1 - Y2).sum()) < 1e-6